"use strict";

const events_1 = require("events");
const child_process_1 = require("child_process");
const path = require("path");
const os_1 = require("os");
const bintray_1 = require("../../src/publish/bintray");
const restApiRequest_1 = require("../../src/publish/restApiRequest");
const semver = require("semver");
//noinspection JSUnusedLocalSymbols
const __awaiter = require("../../src/util/awaiter");
class BintrayProvider {
    constructor(configuration) {
        this.client = new bintray_1.BintrayClient(configuration.user, configuration.package, configuration.repo);
    }
    getLatestVersion() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const data = yield this.client.getVersion("_latest");
                return {
                    version: data.name
                };
            } catch (e) {
                if (e instanceof restApiRequest_1.HttpError && e.response.statusCode === 404) {
                    throw new Error(`No latest version, please ensure that user, package and repository correctly configured. Or at least one version is published. ${ e.stack || e.message }`);
                }
                throw e;
            }
        });
    }
    getUpdateFile(versionInfo) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const files = yield this.client.getVersionFiles(versionInfo.version);
                const suffix = `${ versionInfo.version }.exe`;
                for (let file of files) {
                    if (file.name.endsWith(suffix) && file.name.indexOf("Setup") !== -1) {
                        return {
                            url: ""
                        };
                    }
                }
                //noinspection ExceptionCaughtLocallyJS
                throw new Error(`Cannot find suitable file for version ${ versionInfo.version } in: ${ JSON.stringify(files, null, 2) }`);
            } catch (e) {
                if (e instanceof restApiRequest_1.HttpError && e.response.statusCode === 404) {
                    throw new Error(`No latest version, please ensure that user, package and repository correctly configured. Or at least one version is published. ${ e.stack || e.message }`);
                }
                throw e;
            }
        });
    }
}
class NsisUpdater extends events_1.EventEmitter {
    constructor(updateUrl) {
        super();
        this.updateUrl = updateUrl;
        this.setupPath = path.join(os_1.tmpdir(), 'innobox-upgrade.exe');
        this.updateAvailable = false;
        this.quitAndInstallCalled = false;
        this.app = global.__test_app || require("electron").app;
    }
    getFeedURL() {
        return this.updateUrl;
    }
    setFeedURL(value) {
        this.updateUrl = value.toString();
        this.client = new BintrayProvider(value);
    }
    checkForUpdates() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.updateUrl == null) {
                const message = "Update URL is not set";
                this.emitError(message);
                throw new Error(message);
            }
            this.emit("checking-for-update");
            const versionInfo = yield this.client.getLatestVersion();
            const latestVersion = semver.valid(versionInfo.version);
            if (latestVersion == null) {
                const error = `Latest version (from update server) is not valid semver version: "${ latestVersion }`;
                this.emitError(error);
                throw new Error(error);
            }
            const currentVersion = semver.valid(this.app.getVersion());
            if (currentVersion == null) {
                const error = `App version is not valid semver version: "${ currentVersion }`;
                this.emitError(error);
                throw new Error(error);
            }
            if (semver.gte(currentVersion, latestVersion)) {
                this.updateAvailable = false;
                this.emit("update-not-available");
                return {
                    versionInfo: versionInfo
                };
            }
            this.updateAvailable = true;
            this.emit("update-available");
            return {
                versionInfo: versionInfo,
                downloadPromise: this.client.getUpdateFile(versionInfo).then(it => {})
            };
        });
    }
    quitAndInstall() {
        if (!this.updateAvailable) {
            this.emitError("No update available, can't quit and install");
            return;
        }
        if (this.quitAndInstallCalled) {
            return;
        }
        // prevent calling several times
        this.quitAndInstallCalled = true;
        child_process_1.spawn(this.setupPath, ["/S"], {
            detached: true,
            stdio: "ignore"
        }).unref();
        this.app.quit();
    }
    // emit both error object and message, this is to keep compatibility with old APIs
    emitError(message) {
        return this.emit("error", new Error(message), message);
    }
}
exports.NsisUpdater = NsisUpdater;
//# sourceMappingURL=nsis-updater.js.map